<%#
  Struct declarations
%>
<%
  @structs.each do |struct|
%>
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct __sklib_<%= struct[:name] %> {
<%
    struct[:fields].each do |field_name, field_data|
      field_name = field_name.to_s.to_snake_case
%>
    <%= lib_struct_field_for(field_name, field_data) %>,
<%
    end
%>
}
impl __sklib_<%= struct[:name] %> {
    pub fn new() -> Self {
        let uninit = MaybeUninit::zeroed();
        unsafe { uninit.assume_init() }
    }
}
<%
    # Only derive PartialEq for non-color structs
    derives = struct[:name] == "color" ? "Debug, Clone, Copy" : "Debug, Clone, Copy, PartialEq"
%>
#[derive(<%= derives %>)]
pub struct <%= struct[:name].to_pascal_case %> {
<%
    struct[:fields].each do |field_name, field_data|
      field_name = field_name.to_s.to_snake_case
%>
    <%= sk_struct_field_for(field_name, field_data) %>,
<%
    end
%>
}
impl Default for <%= struct[:name].to_pascal_case %> {
    fn default() -> Self {
        Self::new()
    }
}
impl <%= struct[:name].to_pascal_case %> {
    pub fn new() -> Self {
        let uninit = MaybeUninit::zeroed();
        unsafe { uninit.assume_init() }
    }
    pub fn is_null(&self) -> bool {
        *self == Self::default()
    }
}
<%
    if struct[:name] == "color"
%>
impl PartialEq for <%= struct[:name].to_pascal_case %> {
    fn eq(&self, other: &Self) -> bool {
        (self.r - other.r).abs() < 0.004 &&
        (self.g - other.g).abs() < 0.004 &&
        (self.b - other.b).abs() < 0.004 &&
        (self.a - other.a).abs() < 0.004
    }
}
<%
    end
%>
<%
  end # structs.each
%>